/**
 * Implementação de pilha usando lista encadeada
 * @author Víctor Dimitri
 */
public class LinkedStack<T> implements Stackable<T> {
    private DoubleNode<T> top;
    private int size;
    
    /**
     * Construtor que inicializa uma pilha vazia
     */
    public LinkedStack() {
        this.top = null;
        this.size = 0;
    }
    
    @Override
    public void push(T element) {
        DoubleNode<T> newNode = new DoubleNode<>(element);
        
        if (isEmpty()) {
            top = newNode;
        } else {
            newNode.setNext(top);
            top.setPrevious(newNode);
            top = newNode;
        }
        size++;
    }
    
    @Override
    public T pop() {
        if (isEmpty()) {
            throw new IllegalStateException("A pilha está vazia. Não é possível remover elementos.");
        }
        
        T removedData = top.getData();
        top = top.getNext();
        
        if (top != null) {
            top.setPrevious(null);
        }
        
        size--;
        return removedData;
    }
    
    @Override
    public T peek() {
        if (isEmpty()) {
            throw new IllegalStateException("A pilha está vazia. Não é possível visualizar o topo.");
        }
        
        return top.getData();
    }
    
    @Override
    public boolean isEmpty() {
        return top == null;
    }
    
    @Override
    public int size() {
        return size;
    }
    
    @Override
    public void clear() {
        top = null;
        size = 0;
    }
    
    /**
     * Exibe todos os elementos da pilha (do topo para a base)
     */
    public void display() {
        if (isEmpty()) {
            System.out.println("Pilha vazia");
            return;
        }
        
        DoubleNode<T> current = top;
        System.out.print("Topo -> ");
        while (current != null) {
            System.out.print(current.getData());
            if (current.getNext() != null) {
                System.out.print(" -> ");
            }
            current = current.getNext();
        }
        System.out.println(" <- Base");
    }
    
    /**
     * Verifica se um elemento está na pilha
     * @param element Elemento a ser buscado
     * @return true se o elemento estiver na pilha, false caso contrário
     */
    public boolean contains(T element) {
        DoubleNode<T> current = top;
        while (current != null) {
            if (current.getData().equals(element)) {
                return true;
            }
            current = current.getNext();
        }
        return false;
    }
}
