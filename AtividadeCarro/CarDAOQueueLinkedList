import java.time.Year;
import java.util.Arrays;
import java.util.NoSuchElementException;

// ========================================================================
// 1. CLASSE MODELO: Car.java
// ========================================================================

/**
 * Classe modelo para representar um Carro.
 */
class Car {
    private String plate;
    private String manufacturer;
    private String model;
    private Year manufactureYear;
    private double price;

    public Car(String plate, String manufacturer, String model, Year manufactureYear, double price) {
        this.plate = plate;
        this.manufacturer = manufacturer;
        this.model = model;
        this.manufactureYear = manufactureYear;
        this.price = price;
    }

    // Getters
    public String getPlate() {
        return plate;
    }

    public String getManufacturer() {
        return manufacturer;
    }

    public String getModel() {
        return model;
    }

    public Year getManufactureYear() {
        return manufactureYear;
    }

    public double getPrice() {
        return price;
    }

    // Setters (para a operação de update)
    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public void setManufactureYear(Year manufactureYear) {
        this.manufactureYear = manufactureYear;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Car{" +
                "plate='" + plate + '\'' +
                ", manufacturer='" + manufacturer + '\'' +
                ", model='" + model + '\'' +
                ", year=" + manufactureYear +
                ", price=" + String.format("%.2f", price) +
                '}';
    }
}

// ========================================================================
// 2. INTERFACE ESTRUTURA DE DADOS: Queueable.java
// ========================================================================

/**
 * Interface para estruturas de dados do tipo Fila (Queue).
 */
interface Queueable<T> {
    void enqueue(T element);
    T dequeue();
    T peek();
    boolean isEmpty();
    boolean isFull();
}

// ========================================================================
// 3. ESTRUTURA DE DADOS: LinkedQueue.java
// ========================================================================

/**
 * Implementação de Fila (Queue) usando Lista Encadeada.
 */
class LinkedQueue<T> implements Queueable<T> {

    // Classe interna para representar um nó
    private static class Node<T> {
        T data;
        Node<T> next;

        public Node(T data) {
            this.data = data;
            this.next = null;
        }
    }

    private Node<T> front; // Frente da fila
    private Node<T> rear;  // Traseira da fila
    private int size;
    private final int capacity;

    public LinkedQueue(int capacity) {
        this.front = null;
        this.rear = null;
        this.size = 0;
        this.capacity = capacity;
    }

    @Override
    public void enqueue(T element) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full. Cannot enqueue element.");
        }
        Node<T> newNode = new Node<>(element);
        if (isEmpty()) {
            front = newNode;
        } else {
            rear.next = newNode;
        }
        rear = newNode;
        size++;
    }

    @Override
    public T dequeue() {
        if (isEmpty()) {
            // Retorna null conforme a necessidade de DAOs de não lançar exceções para estruturas vazias
            return null;
        }
        T data = front.data;
        front = front.next;
        if (front == null) {
            rear = null;
        }
        size--;
        return data;
    }

    @Override
    public T peek() {
        if (isEmpty()) {
            return null;
        }
        return front.data;
    }

    @Override
    public boolean isEmpty() {
        return front == null;
    }

    @Override
    public boolean isFull() {
        return size >= capacity;
    }

    @Override
    public String toString() {
        if (isEmpty()) {
            return "[]";
        }
        StringBuilder sb = new StringBuilder();
        sb.append("[FRONT] -> ");
        Node<T> current = front;
        while (current != null) {
            sb.append(current.data);
            if (current.next != null) {
                sb.append(" -> ");
            }
            current = current.next;
        }
        sb.append(" <- [REAR]");
        return sb.toString();
    }
}

// ========================================================================
// 4. INTERFACE DAO: CarDAO.java
// ========================================================================

/**
 * Interface DAO (Data Access Object) para gerenciamento de carros.
 */
interface CarDAO {
    // Operações básicas CRUD
    void addCar(Car car);
    Car getCarByPlate(String plate);
    Car[] getAllCars();
    void updateCar(Car newCar);
    Car removeCarByPlate(String plate);

    // Operações de consulta específicas para carros
    Car[] getCarsByManufacturer(String manufacturer);
    Car[] getCarsByModel(String model);
    Car[] getCarsByYear(Year year);
    Car[] getCarsByPriceRange(double minPrice, double maxPrice);
    Car[] getCarsByManufactureYearRange(Year minYear, Year maxYear);

    // Operações de análise e estatísticas
    Car getMostExpensiveCar();
    Car getCheapestCar();
    Car getNewestCar();
    Car getOldestCar();

    // Operações de relatório e estatísticas
    String printCars();
    int getTotalCars();
    double getAveragePrice();

    // Operações de gerenciamento
    boolean isCarAvailable(String plate);
    void clearAllCars();
}

// ========================================================================
// 5. IMPLEMENTAÇÃO DAO: CarDAOQueueLinkedList.java (CORRIGIDO)
// ========================================================================

/**
 * Implementação do DAO para carros utilizando uma fila baseada em lista encadeada.
 * Inclui todas as correções de inicialização de variáveis.
 */
class CarDAOQueueLinkedList implements CarDAO {

    /**
     * Fila principal para armazenamento dos carros.
     */
    private Queueable<Car> queueCars = new LinkedQueue<>(20);

    // Operações básicas CRUD
    @Override
    public void addCar(Car car) {
        queueCars.enqueue(car);
    }

    @Override
    public Car[] getAllCars() {
        return queueToArray(queueCars);
    }

    @Override
    public void updateCar(Car newCar) {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);

        while (!queueCars.isEmpty()) {
            Car car = queueCars.dequeue();
            if (car.getPlate() != null && car.getPlate().equalsIgnoreCase(newCar.getPlate())) {
                tempQueueCars.enqueue(newCar);
            } else {
                tempQueueCars.enqueue(car);
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }
    }

    @Override
    public Car removeCarByPlate(String plate) {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Car resultCar = null;

        while (!queueCars.isEmpty()) {
            Car car = queueCars.dequeue();
            if (car.getPlate() != null && car.getPlate().equalsIgnoreCase(plate)) {
                resultCar = car;
            } else {
                tempQueueCars.enqueue(car);
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return resultCar;
    }

    // Operações de consulta específicas
    @Override
    public Car getCarByPlate(String plate) {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Car resultCar = null;

        while (!queueCars.isEmpty()) {
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);
            if (resultCar == null && car.getPlate() != null && car.getPlate().equalsIgnoreCase(plate)) {
                resultCar = car;
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return resultCar;
    }

    @Override
    public Car[] getCarsByManufacturer(String manufacturer) {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Queueable<Car> resultQueueCars = new LinkedQueue<>(20);

        while (!queueCars.isEmpty()) {
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);
            if (car.getManufacturer() != null && car.getManufacturer().equalsIgnoreCase(manufacturer)) {
                resultQueueCars.enqueue(car);
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return queueToArray(resultQueueCars);
    }

    @Override
    public Car[] getCarsByModel(String model) {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Queueable<Car> resultQueueCars = new LinkedQueue<>(20);

        while (!queueCars.isEmpty()) {
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);
            if (car.getModel() != null && car.getModel().equalsIgnoreCase(model)) {
                resultQueueCars.enqueue(car);
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return queueToArray(resultQueueCars);
    }

    @Override
    public Car[] getCarsByYear(Year year) {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Queueable<Car> resultQueueCars = new LinkedQueue<>(20);

        while (!queueCars.isEmpty()) {
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);
            if (car.getManufactureYear() != null && car.getManufactureYear().equals(year)) {
                resultQueueCars.enqueue(car);
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return queueToArray(resultQueueCars);
    }

    @Override
    public Car[] getCarsByPriceRange(double minPrice, double maxPrice) {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Queueable<Car> resultQueueCars = new LinkedQueue<>(20);

        while (!queueCars.isEmpty()) {
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);
            if (car.getPrice() >= minPrice && car.getPrice() <= maxPrice) {
                resultQueueCars.enqueue(car);
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return queueToArray(resultQueueCars);
    }

    @Override
    public Car[] getCarsByManufactureYearRange(Year minYear, Year maxYear) {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Queueable<Car> resultQueueCars = new LinkedQueue<>(20);

        while (!queueCars.isEmpty()) {
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);
            if (car.getManufactureYear() != null &&
                    !car.getManufactureYear().isBefore(minYear) &&
                    !car.getManufactureYear().isAfter(maxYear)) {
                resultQueueCars.enqueue(car);
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return queueToArray(resultQueueCars);
    }

    // Operações de análise e estatísticas (CORRIGIDAS)
    @Override
    public Car getMostExpensiveCar() {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Car resultCar = null;

        if (!queueCars.isEmpty()){
            // 1. Processa o primeiro carro
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);

            // Inicializa resultCar com o primeiro carro com preço válido
            if (car.getPrice() > 0) {
                resultCar = car;
            }

            // 2. Processa o restante da fila
            while (!queueCars.isEmpty()) {
                car = queueCars.dequeue();
                tempQueueCars.enqueue(car);

                if (car.getPrice() > 0) {
                    // Atualiza se resultCar for nulo OU se o preço for maior.
                    if (resultCar == null || car.getPrice() > resultCar.getPrice()) {
                        resultCar = car;
                    }
                }
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return resultCar;
    }

    @Override
    public Car getCheapestCar() {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Car resultCar = null;

        if (!queueCars.isEmpty()){
            // 1. Processa o primeiro carro
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);

            // Inicializa resultCar com o primeiro carro com preço válido
            if (car.getPrice() > 0) {
                resultCar = car;
            }

            // 2. Processa o restante da fila
            while (!queueCars.isEmpty()) {
                car = queueCars.dequeue();
                tempQueueCars.enqueue(car);

                if (car.getPrice() > 0) {
                    // Atualiza se resultCar for nulo OU se o preço for menor.
                    if (resultCar == null || car.getPrice() < resultCar.getPrice()) {
                        resultCar = car;
                    }
                }
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return resultCar;
    }

    @Override
    public Car getNewestCar() {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Car resultCar = null;

        if (!queueCars.isEmpty()){
            // 1. Processa o primeiro carro
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);

            // Inicializa resultCar com o primeiro carro com ano válido
            if (car.getManufactureYear() != null) {
                resultCar = car;
            }

            // 2. Processa o restante da fila
            while (!queueCars.isEmpty()) {
                car = queueCars.dequeue();
                tempQueueCars.enqueue(car);

                if (car.getManufactureYear() != null) {
                    // Atualiza se resultCar for nulo OU se o ano for posterior (mais novo).
                    if (resultCar == null || car.getManufactureYear().isAfter(resultCar.getManufactureYear())) {
                        resultCar = car;
                    }
                }
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return resultCar;
    }

    @Override
    public Car getOldestCar() {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        Car resultCar = null;

        if (!queueCars.isEmpty()){
            // 1. Processa o primeiro carro
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);

            // Inicializa resultCar com o primeiro carro com ano válido
            if (car.getManufactureYear() != null) {
                resultCar = car;
            }

            // 2. Processa o restante da fila
            while (!queueCars.isEmpty()) {
                car = queueCars.dequeue();
                tempQueueCars.enqueue(car);

                if (car.getManufactureYear() != null) {
                    // Atualiza se resultCar for nulo OU se o ano for anterior (mais antigo).
                    if (resultCar == null || car.getManufactureYear().isBefore(resultCar.getManufactureYear())) {
                        resultCar = car;
                    }
                }
            }
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return resultCar;
    }

    // Operações de relatório
    @Override
    public String printCars() {
        return queueCars.toString();
    }

    @Override
    public int getTotalCars() {
        return countElements(queueCars);
    }

    @Override
    public double getAveragePrice() {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        double totalPrice = 0.0;
        int carCount = 0;

        while (!queueCars.isEmpty()) {
            Car car = queueCars.dequeue();
            tempQueueCars.enqueue(car);
            totalPrice += car.getPrice();
            carCount++;
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queueCars.enqueue(tempQueueCars.dequeue());
        }

        return carCount > 0 ? totalPrice / carCount : 0.0;
    }

    // Operações de gerenciamento
    @Override
    public boolean isCarAvailable(String plate) {
        return getCarByPlate(plate) != null;
    }

    @Override
    public void clearAllCars() {
        while (!queueCars.isEmpty()) {
            queueCars.dequeue();
        }
    }

    // Métodos auxiliares
    private int countElements(Queueable<Car> queue) {
        Queueable<Car> tempQueueCars = new LinkedQueue<>(20);
        int count = 0;

        while (!queue.isEmpty()) {
            tempQueueCars.enqueue(queue.dequeue());
            count++;
        }

        // Restaurar a fila original
        while (!tempQueueCars.isEmpty()) {
            queue.enqueue(tempQueueCars.dequeue());
        }

        return count;
    }

    private Car[] queueToArray(Queueable<Car> queue) {
        Car[] resultArrayCars = new Car[countElements(queue)];
        int index = 0;
        // Percorre a fila e insere no array
        while (!queue.isEmpty()) {
            resultArrayCars[index] = queue.dequeue();
            index++;
        }

        return resultArrayCars;
    }
}

// ========================================================================
// 6. CLASSE PRINCIPAL PARA DEMONSTRAÇÃO: Main.java
// ========================================================================

class Main {
    public static void main(String[] args) {
        CarDAO carDAO = new CarDAOQueueLinkedList();

        System.out.println("--- 1. ENFILEIRANDO CARROS (addCar) ---");
        carDAO.addCar(new Car("ABC1A23", "Toyota", "Corolla", Year.of(2020), 85000.00)); // Mais Antigo, Mais Barato (inicial)
        carDAO.addCar(new Car("XYZ9B87", "Honda", "Civic", Year.of(2023), 120000.00));
        carDAO.addCar(new Car("QWE5C43", "Ferrari", "458 Italia", Year.of(2015), 1200000.00)); // Mais Caro
        carDAO.addCar(new Car("ASD2D10", "Toyota", "Yaris", Year.of(2024), 95000.00)); // Mais Novo
        carDAO.addCar(new Car("RTY6E98", "Fiat", "Uno", Year.of(2005), 15000.00));

        System.out.println("Fila atual de carros:\n" + carDAO.printCars());
        System.out.println("Total de carros: " + carDAO.getTotalCars() + "\n");

        System.out.println("--- 2. BUSCA E REMOÇÃO (getCarByPlate / removeCarByPlate) ---");
        Car carroBuscado = carDAO.getCarByPlate("XYZ9B87");
        System.out.println("Carro buscado pela placa XYZ9B87:\n" + carroBuscado);

        Car carroRemovido = carDAO.removeCarByPlate("RTY6E98");
        System.out.println("Carro removido (Fiat Uno):\n" + carroRemovido);
        System.out.println("Fila após remoção:\n" + carDAO.printCars());
        System.out.println("Total de carros: " + carDAO.getTotalCars() + "\n");

        System.out.println("--- 3. OPERAÇÕES DE ANÁLISE ---");
        System.out.println("Carro mais caro: " + carDAO.getMostExpensiveCar());
        System.out.println("Carro mais barato: " + carDAO.getCheapestCar());
        System.out.println("Carro mais novo: " + carDAO.getNewestCar());
        System.out.println("Carro mais antigo: " + carDAO.getOldestCar());
        System.out.println("Preço médio: " + String.format("%.2f", carDAO.getAveragePrice()) + "\n");

        System.out.println("--- 4. BUSCA POR ATRIBUTOS (getCarsByManufacturer) ---");
        Car[] carrosToyota = carDAO.getCarsByManufacturer("Toyota");
        System.out.println("Carros da Toyota:\n" + Arrays.toString(carrosToyota));

        System.out.println("\nFila final (inalterada pelas buscas):\n" + carDAO.printCars());
    }
}
